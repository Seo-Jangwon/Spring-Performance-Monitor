<!--
Copyright (c) 2025 Seo-Jangwon
Licensed under MIT License
-->

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <title>Performance Test Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.5/dist/jsoneditor.min.css"
        rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .header-row button.remove-header {
      display: none;
    }

    .header-row:not(:first-child) button.remove-header {
      display: inline-block;
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin-bottom: 20px;
    }

    .modal-xl {
      max-width: 95%;
    }

    .endpoint-card {
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .endpoint-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .selected-endpoint {
      border: 2px solid #0d6efd;
      background-color: #f8f9fa;
    }

    .method-badge {
      font-size: 0.8rem;
      padding: 0.3rem 0.5rem;
    }

    .method-GET {
      background-color: #28a745;
    }

    .method-POST {
      background-color: #007bff;
    }

    .method-PUT {
      background-color: #ffc107;
    }

    .method-DELETE {
      background-color: #dc3545;
    }

    .services-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .service-item {
      padding: 0.5rem;
      border-bottom: 1px solid #dee2e6;
    }

    .service-item:last-child {
      border-bottom: none;
    }
  </style>
</head>
<body>
<div class="container mt-4">
  <h2>Performance Test Dashboard</h2>

  <!-- 엔드포인트 선택 섹션 -->
  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h4 class="mb-0">Available Endpoints</h4>
      <div class="btn-group">
        <button class="btn btn-outline-secondary btn-sm" onclick="toggleView('list')">List View
        </button>
        <button class="btn btn-outline-secondary btn-sm" onclick="toggleView('card')">Card View
        </button>
      </div>
    </div>
    <div class="card-body">
      <!-- 검색 및 필터링 -->
      <div class="row mb-3">
        <div class="col-md-4">
          <input type="text" class="form-control" id="endpointSearch"
                 placeholder="Search endpoints...">
        </div>
        <div class="col-md-3">
          <select class="form-select" id="methodFilter">
            <option value="">All Methods</option>
            <option value="GET">GET</option>
            <option value="POST">POST</option>
            <option value="PUT">PUT</option>
            <option value="DELETE">DELETE</option>
          </select>
        </div>
      </div>

      <!-- 엔드포인트 목록 (카드 뷰) -->
      <div id="endpointCardsView" class="row g-3">
        <!-- 카드들은 JS로 동적 생성됨 -->
      </div>

      <!-- 엔드포인트 목록 (리스트 뷰) -->
      <div id="endpointListView" class="d-none">
        <table class="table table-hover">
          <thead>
          <tr>
            <th>Method</th>
            <th>URL</th>
            <th>Controller</th>
            <th>Services</th>
            <th>Actions</th>
          </tr>
          </thead>
          <tbody id="endpointListBody">
          <!-- 리스트 항목들은 JS로 동적 생성됨 -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- 테스트 설정 섹션 -->
  <div class="card mb-4">
    <div class="card-header">
      <h4 class="mb-0">Test Configuration</h4>
    </div>
    <div class="card-body">
      <form id="testForm">


        <!-- 선택된 엔드포인트 정보 -->
        <div class="selected-endpoint-info mb-4">
          <h5>Selected Endpoint</h5>
          <div class="alert alert-info">
            <div class="d-flex justify-content-between align-items-center">
              <div>
                <strong id="selectedEndpointMethod">-</strong>
                <span id="selectedEndpointUrl">No endpoint selected</span>
              </div>
              <span class="badge bg-secondary" id="endpoint-description">-</span>
            </div>
          </div>

          <!-- URL Parameters -->
          <div id="parameterSection" class="mt-3" style="display: none;">
            <h6>URL Parameters</h6>
            <!-- 동적 표시 -->
          </div>

          <!-- Request Body -->
          <div id="requestBodySection" class="mt-3">
            <h6>Request Body</h6>
            <div class="mb-2">
              <small class="text-muted">Request Type: <span id="requestType">-</span></small>
            </div>
            <div id="jsonEditor" style="height: 200px;"></div>
          </div>
        </div>

        <div class="mb-3">
          <label class="form-label">Description</label>
          <input type="text" class="form-control" id="description" required>
        </div>

        <!--        &lt;!&ndash; Request Body Editor &ndash;&gt;-->
        <!--        <div class="mb-3" id="requestBodySection">-->
        <!--          <label class="form-label">Request Body</label>-->
        <!--          <div id="jsonEditor" style="height: 200px;"></div>-->
        <!--        </div>-->

        <!-- Headers Section -->
        <div class="mb-3">
          <label class="form-label">Headers</label>
          <div id="headersContainer">
            <div class="header-row d-flex mb-2">
              <input type="text" class="form-control me-2" placeholder="Key">
              <input type="text" class="form-control me-2" placeholder="Value">
              <button type="button" class="btn btn-secondary btn-sm add-header">+</button>
              <button type="button" class="btn btn-danger btn-sm ms-2 remove-header">-</button>
            </div>
          </div>
        </div>

        <!-- Test Parameters -->
        <div class="row">
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Concurrent Users</label>
              <input type="number" class="form-control" id="concurrentUsers" value="1" min="1">
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Repeat Count</label>
              <input type="number" class="form-control" id="repeatCount" value="1" min="1">
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Ramp-up Seconds</label>
              <input type="number" class="form-control" id="rampUpSeconds" value="0" min="0">
            </div>
          </div>
        </div>

        <button type="submit" class="btn btn-primary" id="runTestBtn" disabled>
          Run Test
        </button>
      </form>
    </div>
  </div>

  <!-- 테스트 결과 목록 -->
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h4 class="mb-0">Test Results</h4>
      <button class="btn btn-outline-secondary btn-sm" onclick="clearResults()">
        Clear Results
      </button>
    </div>
    <div class="card-body">
      <table class="table">
        <thead>
        <tr>
          <th>Description</th>
          <th>URL</th>
          <th>Status</th>
          <th>Avg Response Time</th>
          <th>Max Response Time</th>
          <th>Requests/sec</th>
          <th>Error Rate</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="resultsBody">
        </tbody>
      </table>
    </div>
  </div>
</div>

<div class="modal fade" id="detailsModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Test Details</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <!-- 성능 측정 결과 섹션 -->
        <div class="card mb-4">
          <div class="card-header bg-primary text-white">
            <h5 class="card-title mb-0">Annotated Method Performance</h5>
          </div>
          <div class="card-body">
            <!-- 기본 정보 -->
            <div class="row mb-4">
              <div class="col-md-6">
                <h6>Test Information</h6>
                <table class="table table-sm">
                  <tr>
                    <td>Description:</td>
                    <td id="modal-description"></td>
                  </tr>
                  <tr>
                    <td>URL:</td>
                    <td id="modal-url"></td>
                  </tr>
                  <tr>
                    <td>Method:</td>
                    <td id="modal-method"></td>
                  </tr>
                  <tr>
                    <td>Duration:</td>
                    <td id="modal-duration"></td>
                  </tr>
                </table>
              </div>
              <div class="col-md-6">
                <h6>Performance Results</h6>
                <table class="table table-sm">
                  <tr>
                    <td>Total Requests:</td>
                    <td id="modal-total-requests"></td>
                  </tr>
                  <tr>
                    <td>Success Rate:</td>
                    <td id="modal-success-rate"></td>
                  </tr>
                  <tr>
                    <td>Avg Response Time:</td>
                    <td id="modal-avg-response"></td>
                  </tr>
                  <tr>
                    <td>Requests/sec:</td>
                    <td id="modal-rps"></td>
                  </tr>
                </table>
              </div>
            </div>

            <!-- 응답 시간 차트 -->
            <div class="row">
              <div class="col-12">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Response Time</h6>
                  </div>
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="responseTimeChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 시스템 모니터링 섹션 -->
        <div class="card">
          <div class="card-header bg-info text-white">
            <h5 class="card-title mb-0">System Monitoring</h5>
          </div>
          <div class="card-body">
            <!-- 메모리 차트 -->
            <div class="row">
              <div class="col-md-6 mb-4">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Heap Memory Usage</h6>
                  </div>
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="memoryChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6 mb-4">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Non-Heap Memory Usage</h6>
                  </div>
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="nonHeapChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- 스레드 상태 차트 -->
            <div class="row">
              <div class="col-md-6 mb-4">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Thread Pool Status</h6>
                  </div>
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="threadChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6 mb-4">
                <!-- Method Thread Metrics -->
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Method Thread Details</h6>
                  </div>
                  <div class="card-body">
                    <table class="table table-sm">
                      <tr>
                        <td>Thread Name:</td>
                        <td id="method-thread-name">-</td>
                      </tr>
                      <tr>
                        <td>Thread ID:</td>
                        <td id="method-thread-id">-</td>
                      </tr>
                      <tr>
                        <td>CPU Time:</td>
                        <td id="method-cpu-time">-</td>
                      </tr>
                      <tr>
                        <td>User Time:</td>
                        <td id="method-user-time">-</td>
                      </tr>
                      <tr>
                        <td>Thread State:</td>
                        <td id="method-thread-state">-</td>
                      </tr>
                      <tr>
                        <td>Priority:</td>
                        <td id="method-thread-priority">-</td>
                      </tr>
                      <tr>
                        <td>Is Daemon:</td>
                        <td id="method-thread-daemon">-</td>
                      </tr>
                      <tr>
                        <td>Stack Trace:</td>
                        <td>
                          <button class="btn btn-sm btn-info" onclick="showStackTrace()">
                            View Stack Trace
                          </button>
                        </td>
                      </tr>
                    </table>
                  </div>
                </div>
              </div>
            </div>

            <!-- 메모리 상태 -->
            <div class="row mt-4">
              <div class="col-md-3">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Heap Memory</h6>
                  </div>
                  <div class="card-body">
                    <p class="mb-1">Used: <span id="modal-heap-used">0 MB</span></p>
                    <p class="mb-1">Max: <span id="modal-heap-max">0 MB</span></p>
                    <p class="mb-1">Young Gen: <span id="modal-young-gen">0 MB</span></p>
                    <p class="mb-0">Old Gen: <span id="modal-old-gen">0 MB</span></p>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Non-Heap Memory</h6>
                  </div>
                  <div class="card-body">
                    <p class="mb-1">Used: <span id="modal-nonheap-used">0 MB</span></p>
                    <p class="mb-1">Committed: <span id="modal-nonheap-committed">0 MB</span></p>
                    <p class="mb-0">Metaspace: <span id="modal-metaspace-used">0 MB</span></p>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">GC Activity</h6>
                  </div>
                  <div class="card-body">
                    <p class="mb-1">Young Count: <span id="modal-young-gc-count">0</span></p>
                    <p class="mb-1">Old Count: <span id="modal-old-gc-count">0</span></p>
                    <p class="mb-0">Total Time: <span id="modal-gc-time">0 ms</span></p>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Thread Pool</h6>
                  </div>
                  <div class="card-body">
                    <p class="mb-1">Active: <span id="modal-active-threads">0</span></p>
                    <p class="mb-1">Pool Size: <span id="modal-pool-size">0</span>/<span
                        id="modal-max-pool-size">0</span></p>
                    <p class="mb-0">Queue Size: <span id="modal-queue-size">0</span></p>
                  </div>
                </div>
              </div>
            </div>

            <!-- 스레드 상태 -->
            <div class="row mt-3">
              <div class="col-12">
                <div class="card">
                  <div class="card-header">
                    <h6 class="card-title">Thread States</h6>
                  </div>
                  <div class="card-body">
                    <div class="d-flex justify-content-between">
                      <div>Running: <span id="modal-running-threads"
                                          class="badge bg-success">0</span></div>
                      <div>Waiting: <span id="modal-waiting-threads"
                                          class="badge bg-warning">0</span></div>
                      <div>Blocked: <span id="modal-blocked-threads"
                                          class="badge bg-danger">0</span></div>
                      <div>Total: <span id="modal-total-threads" class="badge bg-info">0</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Stack Trace Modal -->
<div class="modal fade" id="stackTraceModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Stack Trace</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <pre id="stack-trace-content" style="max-height: 500px; overflow-y: auto;"></pre>
      </div>
    </div>
  </div>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.5/dist/jsoneditor.min.js"></script>

<template id="endpointCardTemplate">
  <div class="col-md-6 col-lg-4">
    <div class="card endpoint-card" onclick="selectEndpoint(this)" data-endpoint-id="">
      <div class="card-header">
        <span class="badge method-badge"></span>
        <small class="float-end text-muted"></small>
      </div>
      <div class="card-body">
        <h6 class="card-title text-truncate"></h6>
        <p class="card-text small"></p>
        <div class="services-list">
          <!-- Service items will be added here -->
        </div>
      </div>
    </div>
  </div>
</template>

<script th:inline="javascript">
  // 전역 변수
  let endpointsData = {};
  let selectedEndpoint = null;
  let currentView = 'card'; // 'card' or 'list'

  // 차트 객체
  let responseTimeChart = null;
  let memoryUsageChart = null;
  let nonHeapChart = null;
  let threadChart = null;

  // JSON 에디터 초기화
  const container = document.getElementById('jsonEditor');
  const editor = new JSONEditor(container, {
    mode: 'code',
    statusBar: false,
    mainMenuBar: false
  });
  editor.set({}); // 빈 객체로 초기화

  // 헤더 추가/제거 기능
  document.addEventListener('click', function (e) {
    if (e.target.matches('.add-header')) {
      const headerRow = e.target.closest('.header-row');
      const newRow = headerRow.cloneNode(true);
      // 새 행의 입력값 초기화
      newRow.querySelectorAll('input').forEach(input => input.value = '');
      headerRow.parentNode.insertBefore(newRow, headerRow.nextSibling);
    } else if (e.target.matches('.remove-header')) {
      const headerRow = e.target.closest('.header-row');
      if (document.querySelectorAll('.header-row').length > 1) {
        headerRow.remove();
      }
    }
  });

  // 폼 제출 처리
  document.getElementById('testForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    let jsonBody;
    try {
      jsonBody = editor.get();
    } catch (error) {
      showError('Invalid JSON in request body');
      return;
    }

    const requestData = {
      description: document.getElementById('description').value,
      url: document.getElementById('url').value,
      method: document.getElementById('method').value,
      requestBody: JSON.stringify(jsonBody),
      headers: getHeaders(),
      concurrentUsers: parseInt(document.getElementById('concurrentUsers').value),
      repeatCount: parseInt(document.getElementById('repeatCount').value),
      rampUpSeconds: parseInt(document.getElementById('rampUpSeconds').value)
    };

    try {
      const response = await fetch('/performanceMeasure/run', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
      });

      if (response.ok) {
        const testId = await response.text();
        showSuccess('Test started successfully');
        pollTestStatus(testId);
      } else {
        throw new Error('Failed to start test');
      }
    } catch (error) {
      showError('Error starting test: ' + error.message);
    }
  });

  function getHeaders() {
    const headers = {};
    document.querySelectorAll('.header-row').forEach(row => {
      const keyInput = row.querySelector('input:first-of-type');
      const valueInput = row.querySelector('input:last-of-type');

      if (keyInput && valueInput) {
        const key = keyInput.value.trim();
        const value = valueInput.value.trim();
        if (key && value) {
          headers[key] = value;
        }
      }
    });
    return headers;
  }

  let pollCount = 0;
  const MAX_POLLS = 60;

  async function pollTestStatus(testId) {
    try {
      if (pollCount++ > MAX_POLLS) {
        showError("Test timed out");
        return;
      }

      const response = await fetch(`/performanceMeasure/status/${testId}`);
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const status = await response.json();
      updateResultsTable(status);

      if (!status.completed) {
        setTimeout(() => pollTestStatus(testId), 1000);
      } else {
        showSuccess('Test completed successfully');
      }
    } catch (error) {
      showError(`Error: ${error.message}`);
    }
  }

  function showError(message) {
    showAlert(message, 'danger');
  }

  function showSuccess(message) {
    showAlert(message, 'success');
  }

  function showAlert(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
    document.querySelector('.container').insertBefore(alertDiv, document.querySelector('.card'));
    setTimeout(() => alertDiv.remove(), 5000);
  }

  function updateResultsTable(status) {
    const tbody = document.getElementById('resultsBody');
    let row = tbody.querySelector(`tr[data-test-id="${status.testId}"]`);

    if (!row) {
      row = document.createElement('tr');
      row.setAttribute('data-test-id', status.testId);
      tbody.insertBefore(row, tbody.firstChild);
    }

    const statusText = getStatusText(status);
    const statusClass = getStatusClass(status);

    row.className = statusClass;
    row.innerHTML = `
            <td>${escapeHtml(status.description || '')}</td>
            <td>${escapeHtml(status.url || '')}</td>
            <td>${statusText}</td>
            <td>${formatNumber(status.averageResponseTime)} ms</td>
            <td>${formatNumber(status.maxResponseTime)} ms</td>
            <td>${formatNumber(status.requestsPerSecond)}</td>
            <td>${formatNumber(status.errorRate)}%</td>
            <td>
                <button class="btn btn-sm btn-info" onclick="showDetails('${status.testId}')">Details</button>
            </td>
        `;
  }

  function showDetails(testId) {
    fetch(`/performanceMeasure/status/${testId}`)
    .then(response => response.json())
    .then(result => {
      updateModalContent(result);
      initializeCharts();

      if (result.completed) {
        // 저장된 상태가 있는지 먼저 확인
        const savedState = localStorage.getItem(`test_${testId}`);

        if (savedState) {
          const state = JSON.parse(savedState);
          if (state.metrics) {
            updateMemoryMetrics(state.metrics);
          }
          if (state.threadMetrics) {
            updateMethodThreadMetrics(state.threadMetrics);
          }
        }

        // result에 memoryMetrics가 있는 경우에만 차트 데이터 준비
        if (result.memoryMetrics && result.memoryMetrics.length > 0) {
          const chartData = prepareChartData(result);
          updateAllChartsWithHistory(chartData);
        }
      } else {
        connectWebSocket(testId);
      }

      new bootstrap.Modal(document.getElementById('detailsModal')).show();
    })
    .catch(error => {
      console.error('Error:', error);
      showError('Failed to load test details');
    });
  }

  // 차트 데이터 준비 함수
  function prepareChartData(testResult) {
    if (!testResult.memoryMetrics || !Array.isArray(testResult.memoryMetrics)) {
      return {
        labels: [],
        memoryData: {heap: [], young: [], old: []},
        nonHeapData: {nonHeap: [], metaspace: []},
        threadPoolData: {active: [], queue: [], pool: []},
        responseTimeData: testResult.responseTimes || []
      };
    }

    return {
      labels: testResult.memoryMetrics.map(m => formatTime(m.timestamp)),
      memoryData: {
        heap: testResult.memoryMetrics.map(m => (m.heapUsed || 0) / (1024 * 1024)),
        young: testResult.memoryMetrics.map(m => (m.youngGenUsed || 0) / (1024 * 1024)),
        old: testResult.memoryMetrics.map(m => (m.oldGenUsed || 0) / (1024 * 1024))
      },
      nonHeapData: {
        nonHeap: testResult.memoryMetrics.map(m => (m.nonHeapUsed || 0) / (1024 * 1024)),
        metaspace: testResult.memoryMetrics.map(m => (m.metaspaceUsed || 0) / (1024 * 1024))
      },
      threadPoolData: {
        active: testResult.memoryMetrics.map(m => m.performanceThreadPool?.activeThreads || 0),
        queue: testResult.memoryMetrics.map(m => m.performanceThreadPool?.queueSize || 0),
        pool: testResult.memoryMetrics.map(m => m.performanceThreadPool?.poolSize || 0)
      },
      responseTimeData: testResult.responseTimes || []
    };
  }

  // 모든 차트 한번에 업데이트
  function updateAllChartsWithHistory(chartData) {
    // 힙 메모리 차트
    memoryUsageChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Heap Usage',
          data: chartData.memoryData.heap,
          borderColor: 'rgb(54, 162, 235)'
        },
        {
          label: 'Young Gen',
          data: chartData.memoryData.young,
          borderColor: 'rgb(255, 99, 132)'
        },
        {
          label: 'Old Gen',
          data: chartData.memoryData.old,
          borderColor: 'rgb(75, 192, 192)'
        }
      ]
    };
    memoryUsageChart.update();

    // 논힙 메모리 차트
    nonHeapChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Non-Heap Used',
          data: chartData.nonHeapData.nonHeap,
          borderColor: 'rgb(153, 102, 255)'
        },
        {
          label: 'Metaspace Used',
          data: chartData.nonHeapData.metaspace,
          borderColor: 'rgb(255, 159, 64)'
        }
      ]
    };
    nonHeapChart.update();

    // 스레드 풀 차트
    threadChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Active Threads',
          data: chartData.threadPoolData.active,
          borderColor: 'rgb(75, 192, 192)'
        },
        {
          label: 'Queue Size',
          data: chartData.threadPoolData.queue,
          borderColor: 'rgb(255, 205, 86)'
        },
        {
          label: 'Pool Size',
          data: chartData.threadPoolData.pool,
          borderColor: 'rgb(153, 102, 255)'
        }
      ]
    };
    threadChart.update();

    // 응답 시간 차트
    responseTimeChart.data = {
      labels: chartData.responseTimeData.map((_, i) => i + 1),
      datasets: [{
        label: 'Response Time (ms)',
        data: chartData.responseTimeData,
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }]
    };
    responseTimeChart.update();
  }

  let ws = null;

  function connectWebSocket(testId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      console.log('Closing existing WebSocket connection');
      ws.close();
    }

    try {
      console.log('Connecting to WebSocket...');
      ws = new WebSocket(`ws://${window.location.host}/ws/metrics`);

      ws.onopen = function () {
        console.log('WebSocket connected, sending testId:', testId);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(testId);
        }
      };

      ws.onmessage = function (event) {
        try {
          const data = JSON.parse(event.data);
          console.log('WebSocket received data:', data);

          // 상태 저장 변수
          let lastThreadMetrics = null;

          if (data.threadMetrics) {
            lastThreadMetrics = data.threadMetrics;
            updateMethodThreadMetrics(data.threadMetrics);
          }

          if (data.testStatus) {
            updateTestStatus(data.testStatus);

            // 테스트 완료시에도 마지막 스레드 메트릭 사용
            if (data.testStatus.completed && lastThreadMetrics) {
              updateMethodThreadMetrics(lastThreadMetrics);
            }
          }

          if (data.metrics) {
            updateMemoryMetrics(data.metrics);
            updateChartsWithNewData(data.metrics, data.testStatus);
          }

          // 테스트 완료시 처리
          if (data.testStatus && data.testStatus.completed) {
            const finalState = {
              metrics: data.metrics,
              threadMetrics: lastThreadMetrics || data.threadMetrics,
              testStatus: data.testStatus
            };
            localStorage.setItem(`test_${data.testStatus.testId}`, JSON.stringify(finalState));
          }

        } catch (error) {
          console.error('Error handling WebSocket message:', error);
        }
      };

      ws.onerror = function (error) {
        console.error('WebSocket error:', error);
      };

      ws.onclose = function (event) {
        console.log('WebSocket closed:', event);
        // 재연결 시도
        setTimeout(() => {
          if (!event.wasClean) {
            console.log('Attempting to reconnect...');
            connectWebSocket(testId);
          }
        }, 3000);
      };
    } catch (error) {
      console.error('Error creating WebSocket:', error);
    }
  }

  function updateTestStatus(testStatus) {
    console.log('Updating test status with:', testStatus);
    if (!testStatus) {
      console.warn('Test status is null or undefined');
      return;
    }

    try {
      // 기본 정보 업데이트
      updateElement('modal-description', testStatus.description);
      updateElement('modal-url', testStatus.url);
      updateElement('modal-method', testStatus.method);
      updateElement('modal-duration', calculateDuration(testStatus.startTime, new Date()));

      // 테스트 결과 업데이트
      updateElement('modal-total-requests', testStatus.totalRequests || 0);
      updateElement('modal-success-rate', `${(100 - (testStatus.errorRate || 0)).toFixed(2)}%`);
      updateElement('modal-avg-response', `${(testStatus.averageResponseTime || 0).toFixed(2)} ms`);
      updateElement('modal-rps', (testStatus.requestsPerSecond || 0).toFixed(2));

      console.log('Test status updated successfully');
    } catch (error) {
      console.error('Error updating test status:', error);
    }

    if (testStatus.responseTimes && testStatus.responseTimes.length > 0) {
      responseTimeChart.data = {
        labels: testStatus.responseTimes.map((_, i) => i + 1),
        datasets: [{
          label: 'Response Time (ms)',
          data: testStatus.responseTimes,
          borderColor: 'rgb(75, 192, 192)',
          tension: 0.1
        }]
      };
      responseTimeChart.update('none');  // 애니메이션 없이 즉시 업데이트
    }
  }

  function updateMemoryMetrics(metrics) {
    if (!metrics) {
      return;
    }

    // 값을 저장할 변수
    let lastMetrics = metrics;

    // 이전에 저장된 값이 있으면 사용
    const savedMetrics = localStorage.getItem('lastMemoryMetrics');
    if (savedMetrics) {
      lastMetrics = JSON.parse(savedMetrics);
    }

    // 현재 메트릭이 유효하면 저장
    if (metrics.heapUsed) {
      localStorage.setItem('lastMemoryMetrics', JSON.stringify(metrics));
      lastMetrics = metrics;
    }

    // 힙 메모리 업데이트
    updateElement('modal-heap-used', formatBytes(metrics.heapUsed));
    updateElement('modal-heap-max', formatBytes(metrics.heapMax));
    updateElement('modal-young-gen', formatBytes(metrics.youngGenUsed));
    updateElement('modal-old-gen', formatBytes(metrics.oldGenUsed));

    // 논힙 메모리 업데이트
    updateElement('modal-nonheap-used', formatBytes(metrics.nonHeapUsed));
    updateElement('modal-nonheap-committed', formatBytes(metrics.nonHeapCommitted));
    updateElement('modal-metaspace-used', formatBytes(metrics.metaspaceUsed));

    // GC 메트릭 업데이트
    updateElement('modal-young-gc-count', metrics.youngGcCount);
    updateElement('modal-old-gc-count', metrics.oldGcCount);
    updateElement('modal-gc-time', `${metrics.youngGcTime + metrics.oldGcTime} ms`);

    // Thread Pool 메트릭 업데이트
    const pool = metrics.performanceThreadPool;
    if (pool) {
      updateElement('modal-active-threads', pool.activeThreads);
      updateElement('modal-pool-size', `${pool.poolSize}/${pool.maxPoolSize}`);
      updateElement('modal-queue-size', pool.queueSize);

      // 스레드 상태 업데이트
      updateElement('modal-running-threads', pool.runningThreads);
      updateElement('modal-waiting-threads', pool.waitingThreads);
      updateElement('modal-blocked-threads', pool.blockedThreads);
      updateElement('modal-total-threads', metrics.threadCount);
    }
  }

  function initializeCharts() {
    if (memoryUsageChart) {
      memoryUsageChart.destroy();
    }
    if (responseTimeChart) {
      responseTimeChart.destroy();
    }
    if (nonHeapChart) {
      nonHeapChart.destroy();
    }
    if (threadChart) {
      threadChart.destroy();
    }

    const memoryCtx = document.getElementById('memoryChart').getContext('2d');
    const responseCtx = document.getElementById('responseTimeChart').getContext('2d');
    const nonHeapCtx = document.getElementById('nonHeapChart').getContext('2d');
    const threadCtx = document.getElementById('threadChart').getContext('2d');

    // Memory Chart
    memoryUsageChart = new Chart(memoryCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Heap Usage',
            borderColor: 'rgb(54, 162, 235)',
            data: []
          },
          {
            label: 'Young Gen',
            borderColor: 'rgb(255, 99, 132)',
            data: []
          },
          {
            label: 'Old Gen',
            borderColor: 'rgb(75, 192, 192)',
            data: []
          }
        ]
      },
      options: createChartOptions('Memory Usage (MB)')
    });

    // Non-Heap Memory Chart
    nonHeapChart = new Chart(nonHeapCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Non-Heap Used',
            borderColor: 'rgb(153, 102, 255)',
            data: []
          },
          {
            label: 'Metaspace Used',
            borderColor: 'rgb(255, 159, 64)',
            data: []
          }
        ]
      },
      options: createChartOptions('Non-Heap Memory (MB)')
    });

    // Thread Chart
    threadChart = new Chart(threadCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Active Threads',
            borderColor: 'rgb(75, 192, 192)',
            data: []
          },
          {
            label: 'Queue Size',
            borderColor: 'rgb(255, 205, 86)',
            data: []
          }
        ]
      },
      options: createChartOptions('Thread Pool Status')
    });

    // Response Time Chart
    responseTimeChart = new Chart(responseCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Response Time (ms)',
          borderColor: 'rgb(75, 192, 192)',
          data: []
        }]
      },
      options: createChartOptions('Response Time (ms)')
    });
  }

  function createChartOptions(yAxisLabel) {
    return {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: yAxisLabel
          }
        }
      },
      animation: {
        duration: 0
      }
    };
  }

  // 차트 실시간 업데이트
  function updateChartsWithNewData(metrics, testStatus) {
    if (!metrics || !testStatus) {
      return;
    }

    // if (testStatus.completed) {
    //   return;
    // }

    // 힙 메모리 차트
    updateHeapMemoryChart(metrics);

    // 논힙 메모리 차트
    updateNonHeapMemoryChart(metrics);

    // 스레드 풀 차트
    updateThreadPoolChart(metrics);

    // 응답시간 차트
    updateResponseTimeChart(testStatus);
  }

  function updateHeapMemoryChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);

    if (memoryUsageChart.data.labels.length > 50) {
      memoryUsageChart.data.labels.shift();
      memoryUsageChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    memoryUsageChart.data.labels.push(timestamp);
    memoryUsageChart.data.datasets[0].data.push(metrics.heapUsed / (1024 * 1024));
    memoryUsageChart.data.datasets[1].data.push(metrics.youngGenUsed / (1024 * 1024));
    memoryUsageChart.data.datasets[2].data.push(metrics.oldGenUsed / (1024 * 1024));

    memoryUsageChart.update();
  }

  function updateNonHeapMemoryChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);

    if (nonHeapChart.data.labels.length > 50) {
      nonHeapChart.data.labels.shift();
      nonHeapChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    nonHeapChart.data.labels.push(timestamp);
    nonHeapChart.data.datasets[0].data.push(metrics.nonHeapUsed / (1024 * 1024));
    nonHeapChart.data.datasets[1].data.push(metrics.metaspaceUsed / (1024 * 1024));

    nonHeapChart.update();
  }

  function updateThreadPoolChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);
    const pool = metrics.performanceThreadPool;

    if (!pool) {
      return;
    }

    if (threadChart.data.labels.length > 50) {
      threadChart.data.labels.shift();
      threadChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    threadChart.data.labels.push(timestamp);
    threadChart.data.datasets[0].data.push(pool.activeThreads);
    threadChart.data.datasets[1].data.push(pool.queueSize);

    // 새로운 데이터셋
    if (threadChart.data.datasets.length === 2) {
      threadChart.data.datasets.push({
        label: 'Pool Size',
        borderColor: 'rgb(153, 102, 255)',
        data: [pool.poolSize]
      });
    } else {
      threadChart.data.datasets[2].data.push(pool.poolSize);
    }

    threadChart.update();
  }

  function updateResponseTimeChart(testStatus) {
    responseTimeChart.data = {
      labels: testStatus.responseTimes.map((_, i) => i + 1),
      datasets: [{
        label: 'Response Time (ms)',
        data: testStatus.responseTimes,
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }]
    };

    responseTimeChart.update();
  }

  // 메서드별 스레드 메트릭 업데이트
  function updateMethodThreadMetrics(threadMetrics) {
    console.log('Updating thread metrics:', threadMetrics);
    if (!threadMetrics) {
      clearMethodThreadMetrics();
      return;
    }

    // Thread 정보 업데이트
    updateElement('method-thread-name', threadMetrics.threadName || '-');
    updateElement('method-thread-id', threadMetrics.threadId || '-');
    updateElement('method-cpu-time', formatDuration(threadMetrics.threadCpuTime) || '-');
    updateElement('method-user-time', formatDuration(threadMetrics.threadUserTime) || '-');
    updateElement('method-thread-state', threadMetrics.threadState || '-');
    updateElement('method-thread-priority', threadMetrics.priority || '-');
    updateElement('method-thread-daemon',
        threadMetrics.isDaemon != null ? (threadMetrics.isDaemon ? 'Yes' : 'No') : '-');

    window.currentStackTrace = threadMetrics.stackTrace || null;
  }

  function clearMethodThreadMetrics() {
    document.getElementById('method-thread-name').textContent = '-';
    document.getElementById('method-thread-id').textContent = '-';
    document.getElementById('method-cpu-time').textContent = '-';
    document.getElementById('method-user-time').textContent = '-';
    document.getElementById('method-thread-state').textContent = '-';
    document.getElementById('method-thread-priority').textContent = '-';
    document.getElementById('method-thread-daemon').textContent = '-';
    window.currentStackTrace = null;
  }

  // 스택 트레이스 표시
  function showStackTrace() {
    const stackTraceContent = document.getElementById('stack-trace-content');
    if (!window.currentStackTrace || !Array.isArray(window.currentStackTrace)) {
      stackTraceContent.textContent = 'No stack trace available';
    } else {
      const formattedTrace = window.currentStackTrace
      .map(
          frame => `    at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})`)
      .join('\n');
      stackTraceContent.textContent = formattedTrace || 'Empty stack trace';
    }

    const modal = new bootstrap.Modal(document.getElementById('stackTraceModal'));
    modal.show();
  }

  // 시간 포맷팅
  function formatDuration(nanos) {
    if (!nanos) {
      return '-';
    }
    const ms = nanos / 1_000_000;
    return `${ms.toFixed(2)} ms`;
  }

  // 모달 내용 업데이트
  function updateModalContent(result) {
    if (!result) {
      console.warn('No result data provided to updateModalContent');
      return;
    }

    // 기본 정보 업데이트
    updateElement('modal-description', result.description);
    updateElement('modal-url', result.url);
    updateElement('modal-method', result.method);
    updateElement('modal-duration', calculateDuration(result.startTime, new Date()));

    // 테스트 결과 업데이트
    updateElement('modal-total-requests', result.totalRequests || 0);
    updateElement('modal-success-rate', `${(100 - (result.errorRate || 0)).toFixed(2)}%`);
    updateElement('modal-avg-response', `${(result.averageResponseTime || 0).toFixed(2)} ms`);
    updateElement('modal-rps', (result.requestsPerSecond || 0).toFixed(2));

    // 메모리 메트릭 업데이트
    updateElement('modal-heap-used', formatBytes(result.metrics?.heapUsed || 0));
    updateElement('modal-heap-max', formatBytes(result.metrics?.heapMax || 0));
    updateElement('modal-young-gen', formatBytes(result.metrics?.youngGenUsed || 0));
    updateElement('modal-old-gen', formatBytes(result.metrics?.oldGenUsed || 0));

    updateElement('modal-nonheap-used', formatBytes(result.metrics?.nonHeapUsed || 0));
    updateElement('modal-nonheap-committed', formatBytes(result.metrics?.nonHeapCommitted || 0));
    updateElement('modal-metaspace-used', formatBytes(result.metrics?.metaspaceUsed || 0));

    updateElement('modal-young-gc-count', result.metrics?.youngGcCount || 0);
    updateElement('modal-old-gc-count', result.metrics?.oldGcCount || 0);
    updateElement('modal-gc-time',
        `${result.metrics?.youngGcTime + result.metrics?.oldGcTime || 0} ms`);

    // 스레드 상태 업데이트
    updateElement('modal-active-threads', result.metrics?.activeThreads || 0);
    updateElement('modal-pool-size', result.metrics?.poolSize || 0);
    updateElement('modal-max-pool-size', result.metrics?.maxPoolSize || 0);
    updateElement('modal-queue-size', result.metrics?.queueSize || 0);

    // 스레드 상태 카운트 업데이트
    updateElement('modal-running-threads', result.metrics?.runningThreads || 0);
    updateElement('modal-waiting-threads', result.metrics?.waitingThreads || 0);
    updateElement('modal-blocked-threads', result.metrics?.blockedThreads || 0);
    updateElement('modal-total-threads', result.metrics?.threadCount || 0);

    // 메서드 스레드 메트릭 업데이트
    if (result.threadMetrics) {
      updateMethodThreadMetrics(result.threadMetrics);
    }
  }

  // 헬퍼 함수들
  function updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) {
      element.textContent = value;
    }
  }

  function formatBytes(bytes) {
    if (!bytes) {
      return '0 MB';
    }
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(2)} MB`;
  }

  function calculateDuration(startTime, endTime) {
    if (!startTime) {
      return '0 seconds';
    }
    const start = new Date(startTime);
    const end = new Date(endTime);
    const diff = (end - start) / 1000;
    return `${diff.toFixed(1)} seconds`;
  }

  function escapeHtml(unsafe) {
    if (unsafe == null) {
      return '';
    }
    return unsafe
    .toString()
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
  }

  function formatNumber(value) {
    if (value == null) {
      return '-';
    }
    return typeof value === 'number' ? value.toFixed(2) : value;
  }

  function getStatusText(status) {
    if (!status) {
      return '-';
    }
    if (status.status === 'ERROR') {
      return 'Error';
    }
    if (status.status === 'TIMEOUT') {
      return 'Timeout';
    }
    if (status.completed) {
      return 'Completed';
    }
    return 'Running';
  }

  function getStatusClass(status) {
    if (!status) {
      return '';
    }
    if (status.status === 'ERROR' || status.status === 'TIMEOUT') {
      return 'table-danger';
    }
    if (status.completed) {
      return status.errorRate > 10 ? 'table-warning' : 'table-success';
    }
    return 'table-info';
  }

  function formatTime(timestamp) {
    // timestamp가 배열인 경우
    if (Array.isArray(timestamp)) {
      const [year, month, day, hour, minute, second, nano] = timestamp;
      return `${hour}:${minute}:${second}`;
    }
    // 문자열인 경우
    const date = new Date(timestamp);
    return date.toLocaleTimeString();
  }

  // 페이지 로드 시 초기화
  window.addEventListener('load', async () => {
    try {
      // 엔드포인트 데이터 로드
      const response = await fetch('/performanceMeasure/endpoints');
      if (response.ok) {
        endpointsData = await response.json();
        initializeEndpointView();
      }

      // 테스트 결과 로드
      const resultsResponse = await fetch('/performanceMeasure/results');
      if (resultsResponse.ok) {
        const results = await resultsResponse.json();
        results.forEach(result => updateResultsTable(result));
      }
    } catch (error) {
      console.error('Failed to load initial data:', error);
      showError('Failed to load test endpoints');
    }
  });

  // 엔드포인트 뷰 초기화
  function initializeEndpointView() {
    const cardsContainer = document.getElementById('endpointCardsView');
    const listBody = document.getElementById('endpointListBody');

    cardsContainer.innerHTML = '';
    listBody.innerHTML = '';

    // 엔드포인트 정렬 (HTTP 메서드 순)
    const sortedMethods = Object.keys(endpointsData).sort();

    sortedMethods.forEach(method => {
      endpointsData[method].forEach((endpoint, index) => {

        addEndpointCard(endpoint, method, index);
        addEndpointListItem(endpoint, method, index);
      });
    });

    // 검색 및 필터 이벤트 리스너 설정
    setupSearchAndFilter();
  }

  // 엔드포인트 카드
  function addEndpointCard(endpoint, method, index) {
    const template = document.getElementById('endpointCardTemplate');
    const card = template.content.cloneNode(true);

    const cardDiv = card.querySelector('.endpoint-card');
    cardDiv.dataset.endpointId = `${method}-${index}`;

    const badge = card.querySelector('.method-badge');
    badge.textContent = method;
    badge.classList.add(`method-${method}`);

    const title = card.querySelector('.card-title');
    title.textContent = endpoint.endpointUrl;

    const controller = card.querySelector('.card-text');
    controller.textContent = `${endpoint.controllerClassName}.${endpoint.controllerMethodName}`;

    const servicesList = card.querySelector('.services-list');
    if (endpoint.annotatedServices && endpoint.annotatedServices.length > 0) {
      endpoint.annotatedServices.forEach(service => {
        const serviceItem = document.createElement('div');
        serviceItem.className = 'service-item small';
        serviceItem.innerHTML = `
                <div class="fw-bold">${service.serviceClassName}.${service.methodName}</div>
                <small class="text-muted">${service.description || 'No description'}</small>
            `;
        servicesList.appendChild(serviceItem);
      });
    } else {
      const emptyItem = document.createElement('div');
      emptyItem.className = 'service-item small text-muted';
      emptyItem.textContent = 'No annotated services';
      servicesList.appendChild(emptyItem);
    }

    document.getElementById('endpointCardsView').appendChild(card);
  }

  // 엔드포인트 리스트 항목
  function addEndpointListItem(endpoint, method, index) {
    const tr = document.createElement('tr');
    tr.dataset.endpointId = `${method}-${index}`;

    tr.innerHTML = `
        <td><span class="badge method-badge method-${method}">${method}</span></td>
        <td>${endpoint.endpointUrl}</td>
        <td>${endpoint.controllerClassName}.${endpoint.controllerMethodName}</td>
        <td>${endpoint.annotatedServices?.length || 0} services</td>
        <td>
            <button class="btn btn-sm btn-primary" onclick="selectEndpoint(this.closest('tr'))">
                Select
            </button>
        </td>
    `;

    document.getElementById('endpointListBody').appendChild(tr);
  }

  // 검색 및 필터 설정
  function setupSearchAndFilter() {
    const searchInput = document.getElementById('endpointSearch');
    const methodFilter = document.getElementById('methodFilter');

    const filterEndpoints = () => {
      const searchTerm = searchInput.value.toLowerCase();
      const selectedMethod = methodFilter.value;

      const cards = document.querySelectorAll('.endpoint-card');
      const rows = document.querySelectorAll('#endpointListBody tr');

      [...cards, ...rows].forEach(element => {
        const id = element.dataset.endpointId;
        const [method, index] = id.split('-');
        const endpoint = endpointsData[method][index];

        const matchesSearch = endpoint.endpointUrl.toLowerCase().includes(searchTerm) ||
            endpoint.controllerClassName.toLowerCase().includes(searchTerm);
        const matchesMethod = !selectedMethod || method === selectedMethod;

        element.style.display = (matchesSearch && matchesMethod) ? '' : 'none';
      });
    };

    searchInput.addEventListener('input', filterEndpoints);
    methodFilter.addEventListener('change', filterEndpoints);
  }

  // 엔드포인트 선택
  function selectEndpoint(element) {
    // 이전 선택 해제
    document.querySelectorAll('.selected-endpoint').forEach(el =>
        el.classList.remove('selected-endpoint'));

    // 새로운 선택
    element.classList.add('selected-endpoint');
    const [method, index] = element.dataset.endpointId.split('-');
    selectedEndpoint = {
      ...endpointsData[method][index],
      httpMethod: method
    };

    console.log('Selected Endpoint:', selectedEndpoint); // 디버깅용

    // UI 업데이트
    const methodEl = document.getElementById('selectedEndpointMethod');
    const urlEl = document.getElementById('selectedEndpointUrl');
    const descEl = document.getElementById('endpoint-description');
    const requestTypeEl = document.getElementById('requestType');
    const requestBodySection = document.getElementById('requestBodySection');

    if (methodEl) {
      methodEl.textContent = selectedEndpoint.httpMethod;
    }
    if (urlEl) {
      urlEl.textContent = selectedEndpoint.endpointUrl;
    }
    if (descEl) {
      descEl.textContent = selectedEndpoint.description || '-';
    }
    if (requestTypeEl) {
      requestTypeEl.textContent = selectedEndpoint.requestType;
    }

    // Request Body 섹션 표시/숨김 처리
    if (selectedEndpoint.httpMethod === 'POST' ||
        selectedEndpoint.httpMethod === 'PUT' ||
        (selectedEndpoint.requestType &&
            selectedEndpoint.requestType.toLowerCase() !== 'void')) {
      requestBodySection.style.display = 'block';
      if (editor) {
        if (selectedEndpoint.requestExample &&
            Object.keys(selectedEndpoint.requestExample).length > 0) {
          console.log('Setting request example:', selectedEndpoint.requestExample);
          editor.set(selectedEndpoint.requestExample);
        } else {
          console.log('No request example available, setting empty object');
          editor.set({
            id: 0,
            name: "example"
          });
        }
      }
    } else {
      console.log('Hiding request body section for endpoint:', selectedEndpoint);
      requestBodySection.style.display = 'none';
    }

    // Run Test 버튼 활성화
    const runTestBtn = document.getElementById('runTestBtn');
    if (runTestBtn) {
      runTestBtn.disabled = false;
    }
  }

  // 뷰 전환 (카드/리스트)
  function toggleView(viewType) {
    const cardView = document.getElementById('endpointCardsView');
    const listView = document.getElementById('endpointListView');

    if (viewType === 'card') {
      cardView.classList.remove('d-none');
      listView.classList.add('d-none');
      currentView = 'card';
    } else {
      cardView.classList.add('d-none');
      listView.classList.remove('d-none');
      currentView = 'list';
    }
  }

  // 결과 클리어
  function clearResults() {
    document.getElementById('resultsBody').innerHTML = '';
  }

  // 테스트 폼 제출 처리
  document.getElementById('testForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    if (!selectedEndpoint) {
      showError('Please select an endpoint first');
      return;
    }

    let jsonBody;
    try {
      jsonBody = editor.get();
    } catch (error) {
      showError('Invalid JSON in request body');
      return;
    }

    const requestData = {
      description: document.getElementById('description').value,
      url: window.location.origin + selectedEndpoint.endpointUrl,
      method: selectedEndpoint.httpMethod,
      requestBody: JSON.stringify(jsonBody),
      headers: getHeaders(),
      concurrentUsers: parseInt(document.getElementById('concurrentUsers').value),
      repeatCount: parseInt(document.getElementById('repeatCount').value),
      rampUpSeconds: parseInt(document.getElementById('rampUpSeconds').value)
    };

    try {
      const response = await fetch('/performanceMeasure/run', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
      });

      if (response.ok) {
        const testId = await response.text();
        showSuccess('Test started successfully');
        pollTestStatus(testId);
      } else {
        throw new Error('Failed to start test');
      }
    } catch (error) {
      showError('Error starting test: ' + error.message);
    }
  });

</script>
</body>
</html>