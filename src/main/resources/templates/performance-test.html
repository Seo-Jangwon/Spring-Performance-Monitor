<!--
Copyright (c) 2025 Seo-Jangwon
Licensed under MIT License
-->

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <title>Performance Test Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.5/dist/jsoneditor.min.css"
        rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .header-row button.remove-header {
      display: none;
    }

    .header-row:not(:first-child) button.remove-header {
      display: inline-block;
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin-bottom: 20px;
    }

    .modal-xl {
      max-width: 95%;
    }

    .memory-stats {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
    }

    .memory-stats h6 {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<div class="container mt-4">
  <h2>API Performance Test Dashboard</h2>

  <!-- 테스트 시나리오 입력 폼 -->
  <div class="card mb-4">
    <div class="card-header">
      <h4>New Test Scenario</h4>
    </div>
    <div class="card-body">
      <form id="testForm">
        <div class="mb-3">
          <label class="form-label">Description</label>
          <input type="text" class="form-control" id="description" required>
        </div>
        <div class="mb-3">
          <label class="form-label">URL</label>
          <input type="url" class="form-control" id="url" required>
        </div>
        <div class="mb-3">
          <label class="form-label">HTTP Method</label>
          <select class="form-select" id="method">
            <option>GET</option>
            <option>POST</option>
            <option>PUT</option>
            <option>DELETE</option>
          </select>
        </div>
        <div class="mb-3">
          <label class="form-label">Request Body (JSON)</label>
          <div id="jsonEditor" style="height: 200px;"></div>
        </div>
        <div class="mb-3">
          <label class="form-label">Headers (Key-Value)</label>
          <div id="headersContainer">
            <div class="header-row d-flex mb-2">
              <input type="text" class="form-control me-2" placeholder="Key">
              <input type="text" class="form-control me-2" placeholder="Value">
              <button type="button" class="btn btn-secondary btn-sm add-header">+</button>
              <button type="button" class="btn btn-danger btn-sm ms-2 remove-header">-</button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Concurrent Users</label>
              <input type="number" class="form-control" id="concurrentUsers" value="1" min="1">
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Repeat Count</label>
              <input type="number" class="form-control" id="repeatCount" value="1" min="1">
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label">Ramp-up Seconds</label>
              <input type="number" class="form-control" id="rampUpSeconds" value="0" min="0">
            </div>
          </div>
        </div>
        <button type="submit" class="btn btn-primary">Run Test</button>
      </form>
    </div>
  </div>

  <!-- 테스트 결과 목록 -->
  <div class="card">
    <div class="card-header">
      <h4>Test Results</h4>
    </div>
    <div class="card-body">
      <table class="table">
        <thead>
        <tr>
          <th>Description</th>
          <th>URL</th>
          <th>Status</th>
          <th>Avg Response Time</th>
          <th>Max Response Time</th>
          <th>Requests/sec</th>
          <th>Error Rate</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="resultsBody">
        </tbody>
      </table>
    </div>
  </div>

  <!-- Details Modal -->
  <div class="modal fade" id="detailsModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Test Details</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <!-- 성능 측정 결과 섹션 -->
          <div class="card mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="card-title mb-0">Annotated Method Performance</h5>
            </div>
            <div class="card-body">
              <!-- 기본 정보 -->
              <div class="row mb-4">
                <div class="col-md-6">
                  <h6>Test Information</h6>
                  <table class="table table-sm">
                    <tr>
                      <td>Description:</td>
                      <td id="modal-description"></td>
                    </tr>
                    <tr>
                      <td>URL:</td>
                      <td id="modal-url"></td>
                    </tr>
                    <tr>
                      <td>Method:</td>
                      <td id="modal-method"></td>
                    </tr>
                    <tr>
                      <td>Duration:</td>
                      <td id="modal-duration"></td>
                    </tr>
                  </table>
                </div>
                <div class="col-md-6">
                  <h6>Performance Results</h6>
                  <table class="table table-sm">
                    <tr>
                      <td>Total Requests:</td>
                      <td id="modal-total-requests"></td>
                    </tr>
                    <tr>
                      <td>Success Rate:</td>
                      <td id="modal-success-rate"></td>
                    </tr>
                    <tr>
                      <td>Avg Response Time:</td>
                      <td id="modal-avg-response"></td>
                    </tr>
                    <tr>
                      <td>Requests/sec:</td>
                      <td id="modal-rps"></td>
                    </tr>
                  </table>
                </div>
              </div>

              <!-- 응답 시간 차트 -->
              <div class="row">
                <div class="col-12">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Response Time</h6>
                    </div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="responseTimeChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- 시스템 모니터링 섹션 -->
          <div class="card">
            <div class="card-header bg-info text-white">
              <h5 class="card-title mb-0">System Monitoring</h5>
            </div>
            <div class="card-body">
              <!-- 메모리 차트 -->
              <div class="row">
                <div class="col-md-6 mb-4">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Heap Memory Usage</h6>
                    </div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="memoryChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="col-md-6 mb-4">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Non-Heap Memory Usage</h6>
                    </div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="nonHeapChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- 스레드 상태 차트 -->
              <div class="row">
                <div class="col-md-6 mb-4">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Thread Pool Status</h6>
                    </div>
                    <div class="card-body">
                      <div class="chart-container">
                        <canvas id="threadChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="col-md-6 mb-4">
                  <!-- Method Thread Metrics -->
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Method Thread Details</h6>
                    </div>
                    <div class="card-body">
                      <table class="table table-sm">
                        <tr>
                          <td>Thread Name:</td>
                          <td id="method-thread-name">-</td>
                        </tr>
                        <tr>
                          <td>Thread ID:</td>
                          <td id="method-thread-id">-</td>
                        </tr>
                        <tr>
                          <td>CPU Time:</td>
                          <td id="method-cpu-time">-</td>
                        </tr>
                        <tr>
                          <td>User Time:</td>
                          <td id="method-user-time">-</td>
                        </tr>
                        <tr>
                          <td>Thread State:</td>
                          <td id="method-thread-state">-</td>
                        </tr>
                        <tr>
                          <td>Priority:</td>
                          <td id="method-thread-priority">-</td>
                        </tr>
                        <tr>
                          <td>Is Daemon:</td>
                          <td id="method-thread-daemon">-</td>
                        </tr>
                        <tr>
                          <td>Stack Trace:</td>
                          <td>
                            <button class="btn btn-sm btn-info" onclick="showStackTrace()">
                              View Stack Trace
                            </button>
                          </td>
                        </tr>
                      </table>
                    </div>
                  </div>
                </div>
              </div>

              <!-- 메모리 상태 -->
              <div class="row mt-4">
                <div class="col-md-3">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Heap Memory</h6>
                    </div>
                    <div class="card-body">
                      <p class="mb-1">Used: <span id="modal-heap-used">0 MB</span></p>
                      <p class="mb-1">Max: <span id="modal-heap-max">0 MB</span></p>
                      <p class="mb-1">Young Gen: <span id="modal-young-gen">0 MB</span></p>
                      <p class="mb-0">Old Gen: <span id="modal-old-gen">0 MB</span></p>
                    </div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Non-Heap Memory</h6>
                    </div>
                    <div class="card-body">
                      <p class="mb-1">Used: <span id="modal-nonheap-used">0 MB</span></p>
                      <p class="mb-1">Committed: <span id="modal-nonheap-committed">0 MB</span></p>
                      <p class="mb-0">Metaspace: <span id="modal-metaspace-used">0 MB</span></p>
                    </div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">GC Activity</h6>
                    </div>
                    <div class="card-body">
                      <p class="mb-1">Young Count: <span id="modal-young-gc-count">0</span></p>
                      <p class="mb-1">Old Count: <span id="modal-old-gc-count">0</span></p>
                      <p class="mb-0">Total Time: <span id="modal-gc-time">0 ms</span></p>
                    </div>
                  </div>
                </div>
                <div class="col-md-3">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Thread Pool</h6>
                    </div>
                    <div class="card-body">
                      <p class="mb-1">Active: <span id="modal-active-threads">0</span></p>
                      <p class="mb-1">Pool Size: <span id="modal-pool-size">0</span>/<span id="modal-max-pool-size">0</span></p>
                      <p class="mb-0">Queue Size: <span id="modal-queue-size">0</span></p>
                    </div>
                  </div>
                </div>
              </div>

              <!-- 스레드 상태 -->
              <div class="row mt-3">
                <div class="col-12">
                  <div class="card">
                    <div class="card-header">
                      <h6 class="card-title">Thread States</h6>
                    </div>
                    <div class="card-body">
                      <div class="d-flex justify-content-between">
                        <div>Running: <span id="modal-running-threads" class="badge bg-success">0</span></div>
                        <div>Waiting: <span id="modal-waiting-threads" class="badge bg-warning">0</span></div>
                        <div>Blocked: <span id="modal-blocked-threads" class="badge bg-danger">0</span></div>
                        <div>Total: <span id="modal-total-threads" class="badge bg-info">0</span></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Stack Trace Modal -->
  <div class="modal fade" id="stackTraceModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Stack Trace</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <pre id="stack-trace-content" style="max-height: 500px; overflow-y: auto;"></pre>
        </div>
      </div>
    </div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.5/dist/jsoneditor.min.js"></script>
<script th:inline="javascript">
  // JSON 에디터 초기화
  const container = document.getElementById('jsonEditor');
  const editor = new JSONEditor(container, {
    mode: 'code',
    statusBar: false,
    mainMenuBar: false
  });
  editor.set({}); // 빈 객체로 초기화

  // 차트 객체
  let responseTimeChart = null;
  let memoryUsageChart = null;

  // 헤더 추가/제거 기능
  document.addEventListener('click', function (e) {
    if (e.target.matches('.add-header')) {
      const headerRow = e.target.closest('.header-row');
      const newRow = headerRow.cloneNode(true);
      // 새 행의 입력값 초기화
      newRow.querySelectorAll('input').forEach(input => input.value = '');
      headerRow.parentNode.insertBefore(newRow, headerRow.nextSibling);
    } else if (e.target.matches('.remove-header')) {
      const headerRow = e.target.closest('.header-row');
      if (document.querySelectorAll('.header-row').length > 1) {
        headerRow.remove();
      }
    }
  });

  // 폼 제출 처리
  document.getElementById('testForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    let jsonBody;
    try {
      jsonBody = editor.get();
    } catch (error) {
      showError('Invalid JSON in request body');
      return;
    }

    const requestData = {
      description: document.getElementById('description').value,
      url: document.getElementById('url').value,
      method: document.getElementById('method').value,
      requestBody: JSON.stringify(jsonBody),
      headers: getHeaders(),
      concurrentUsers: parseInt(document.getElementById('concurrentUsers').value),
      repeatCount: parseInt(document.getElementById('repeatCount').value),
      rampUpSeconds: parseInt(document.getElementById('rampUpSeconds').value)
    };

    try {
      const response = await fetch('/performanceMeasure/run', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
      });

      if (response.ok) {
        const testId = await response.text();
        showSuccess('Test started successfully');
        pollTestStatus(testId);
      } else {
        throw new Error('Failed to start test');
      }
    } catch (error) {
      showError('Error starting test: ' + error.message);
    }
  });

  function getHeaders() {
    const headers = {};
    document.querySelectorAll('.header-row').forEach(row => {
      const keyInput = row.querySelector('input:first-of-type');
      const valueInput = row.querySelector('input:last-of-type');

      if (keyInput && valueInput) {
        const key = keyInput.value.trim();
        const value = valueInput.value.trim();
        if (key && value) {
          headers[key] = value;
        }
      }
    });
    return headers;
  }

  let pollCount = 0;
  const MAX_POLLS = 60;

  async function pollTestStatus(testId) {
    try {
      if (pollCount++ > MAX_POLLS) {
        showError("Test timed out");
        return;
      }

      const response = await fetch(`/performanceMeasure/status/${testId}`);
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const status = await response.json();
      updateResultsTable(status);

      if (!status.completed) {
        setTimeout(() => pollTestStatus(testId), 1000);
      } else {
        showSuccess('Test completed successfully');
      }
    } catch (error) {
      showError(`Error: ${error.message}`);
    }
  }

  function showError(message) {
    showAlert(message, 'danger');
  }

  function showSuccess(message) {
    showAlert(message, 'success');
  }

  function showAlert(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
    document.querySelector('.container').insertBefore(alertDiv, document.querySelector('.card'));
    setTimeout(() => alertDiv.remove(), 5000);
  }

  function updateResultsTable(status) {
    const tbody = document.getElementById('resultsBody');
    let row = tbody.querySelector(`tr[data-test-id="${status.testId}"]`);

    if (!row) {
      row = document.createElement('tr');
      row.setAttribute('data-test-id', status.testId);
      tbody.insertBefore(row, tbody.firstChild);
    }

    const statusText = getStatusText(status);
    const statusClass = getStatusClass(status);

    row.className = statusClass;
    row.innerHTML = `
            <td>${escapeHtml(status.description || '')}</td>
            <td>${escapeHtml(status.url || '')}</td>
            <td>${statusText}</td>
            <td>${formatNumber(status.averageResponseTime)} ms</td>
            <td>${formatNumber(status.maxResponseTime)} ms</td>
            <td>${formatNumber(status.requestsPerSecond)}</td>
            <td>${formatNumber(status.errorRate)}%</td>
            <td>
                <button class="btn btn-sm btn-info" onclick="showDetails('${status.testId}')">Details</button>
            </td>
        `;
  }

  function showDetails(testId) {
    fetch(`/performanceMeasure/status/${testId}`)
    .then(response => response.json())
    .then(result => {
      updateModalContent(result);

      // 초기 차트 설정
      initializeCharts();

      // 테스트가 완료된 상태면 전체 데이터로 한 번만 업데이트
      if (result.completed) {
        const chartData = prepareChartData(result);
        updateAllChartsWithHistory(chartData);
      } else {
        // 진행 중인 경우에만 웹소켓 연결
        connectWebSocket(testId);
      }

      new bootstrap.Modal(document.getElementById('detailsModal')).show();
    })
    .catch(error => {
      console.error('Error:', error);
      showError('Failed to load test details');
    });
  }

  // 차트 데이터 준비 함수
  function prepareChartData(testResult) {
    return {
      labels: testResult.memoryMetrics.map(m => formatTime(m.timestamp)),
      memoryData: {
        heap: testResult.memoryMetrics.map(m => m.heapUsed / (1024 * 1024)),
        young: testResult.memoryMetrics.map(m => m.youngGenUsed / (1024 * 1024)),
        old: testResult.memoryMetrics.map(m => m.oldGenUsed / (1024 * 1024))
      },
      nonHeapData: {
        nonHeap: testResult.memoryMetrics.map(m => m.nonHeapUsed / (1024 * 1024)),
        metaspace: testResult.memoryMetrics.map(m => m.metaspaceUsed / (1024 * 1024))
      },
      threadPoolData: {
        active: testResult.memoryMetrics.map(m => m.performanceThreadPool?.activeThreads || 0),
        queue: testResult.memoryMetrics.map(m => m.performanceThreadPool?.queueSize || 0),
        pool: testResult.memoryMetrics.map(m => m.performanceThreadPool?.poolSize || 0)
      },
      responseTimeData: testResult.responseTimes || []
    };
  }

  // 모든 차트 한번에 업데이트
  function updateAllChartsWithHistory(chartData) {
    // 힙 메모리 차트
    memoryUsageChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Heap Usage',
          data: chartData.memoryData.heap,
          borderColor: 'rgb(54, 162, 235)'
        },
        {
          label: 'Young Gen',
          data: chartData.memoryData.young,
          borderColor: 'rgb(255, 99, 132)'
        },
        {
          label: 'Old Gen',
          data: chartData.memoryData.old,
          borderColor: 'rgb(75, 192, 192)'
        }
      ]
    };
    memoryUsageChart.update();

    // 논힙 메모리 차트
    nonHeapChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Non-Heap Used',
          data: chartData.nonHeapData.nonHeap,
          borderColor: 'rgb(153, 102, 255)'
        },
        {
          label: 'Metaspace Used',
          data: chartData.nonHeapData.metaspace,
          borderColor: 'rgb(255, 159, 64)'
        }
      ]
    };
    nonHeapChart.update();

    // 스레드 풀 차트
    threadChart.data = {
      labels: chartData.labels,
      datasets: [
        {
          label: 'Active Threads',
          data: chartData.threadPoolData.active,
          borderColor: 'rgb(75, 192, 192)'
        },
        {
          label: 'Queue Size',
          data: chartData.threadPoolData.queue,
          borderColor: 'rgb(255, 205, 86)'
        },
        {
          label: 'Pool Size',
          data: chartData.threadPoolData.pool,
          borderColor: 'rgb(153, 102, 255)'
        }
      ]
    };
    threadChart.update();

    // 응답 시간 차트
    responseTimeChart.data = {
      labels: chartData.responseTimeData.map((_, i) => i + 1),
      datasets: [{
        label: 'Response Time (ms)',
        data: chartData.responseTimeData,
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }]
    };
    responseTimeChart.update();
  }

  let ws = null;

  function connectWebSocket(testId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      console.log('Closing existing WebSocket connection');
      ws.close();
    }

    try {
      console.log('Connecting to WebSocket...');
      ws = new WebSocket(`ws://${window.location.host}/ws/metrics`);

      ws.onopen = function () {
        console.log('WebSocket connected, sending testId:', testId);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(testId);
        }
      };

      ws.onmessage = function (event) {
        try {
          const data = JSON.parse(event.data);

          if (data.testStatus) {
            updateTestStatus(data.testStatus);
          }

          if (data.metrics) {
            updateMemoryMetrics(data.metrics);
          }

          if (data.threadMetrics) {
            updateMethodThreadMetrics(data.threadMetrics);
          }

          updateChartsWithNewData(data.metrics, data.testStatus);

        } catch (error) {
          console.error('Error handling WebSocket message:', error);
        }
      };

      ws.onerror = function (error) {
        console.error('WebSocket error:', error);
      };

      ws.onclose = function (event) {
        console.log('WebSocket closed:', event);
        // 재연결 시도
        setTimeout(() => {
          if (!event.wasClean) {
            console.log('Attempting to reconnect...');
            connectWebSocket(testId);
          }
        }, 3000);
      };
    } catch (error) {
      console.error('Error creating WebSocket:', error);
    }
  }

  function updateTestStatus(testStatus) {
    console.log('Updating test status with:', testStatus);
    if (!testStatus) {
      console.warn('Test status is null or undefined');
      return;
    }

    try {
      // 기본 정보 업데이트
      updateElement('modal-description', testStatus.description);
      updateElement('modal-url', testStatus.url);
      updateElement('modal-method', testStatus.method);
      updateElement('modal-duration', calculateDuration(testStatus.startTime, new Date()));

      // 테스트 결과 업데이트
      updateElement('modal-total-requests', testStatus.totalRequests || 0);
      updateElement('modal-success-rate', `${(100 - (testStatus.errorRate || 0)).toFixed(2)}%`);
      updateElement('modal-avg-response', `${(testStatus.averageResponseTime || 0).toFixed(2)} ms`);
      updateElement('modal-rps', (testStatus.requestsPerSecond || 0).toFixed(2));

      console.log('Test status updated successfully');
    } catch (error) {
      console.error('Error updating test status:', error);
    }
  }

  function updateMemoryMetrics(metrics) {
    if (!metrics) {
      return;
    }

    // 힙 메모리 업데이트
    updateElement('modal-heap-used', formatBytes(metrics.heapUsed));
    updateElement('modal-heap-max', formatBytes(metrics.heapMax));
    updateElement('modal-young-gen', formatBytes(metrics.youngGenUsed));
    updateElement('modal-old-gen', formatBytes(metrics.oldGenUsed));

    // 논힙 메모리 업데이트
    updateElement('modal-nonheap-used', formatBytes(metrics.nonHeapUsed));
    updateElement('modal-nonheap-committed', formatBytes(metrics.nonHeapCommitted));
    updateElement('modal-metaspace-used', formatBytes(metrics.metaspaceUsed));

    // GC 메트릭 업데이트
    updateElement('modal-young-gc-count', metrics.youngGcCount);
    updateElement('modal-old-gc-count', metrics.oldGcCount);
    updateElement('modal-gc-time', `${metrics.youngGcTime + metrics.oldGcTime} ms`);

    // Thread Pool 메트릭 업데이트
    const pool = metrics.performanceThreadPool;
    if (pool) {
      updateElement('modal-active-threads', pool.activeThreads);
      updateElement('modal-pool-size', `${pool.poolSize}/${pool.maxPoolSize}`);
      updateElement('modal-queue-size', pool.queueSize);

      // 스레드 상태 업데이트
      updateElement('modal-running-threads', pool.runningThreads);
      updateElement('modal-waiting-threads', pool.waitingThreads);
      updateElement('modal-blocked-threads', pool.blockedThreads);
      updateElement('modal-total-threads', metrics.threadCount);
    }
  }

  let nonHeapChart = null;
  let threadChart = null;

  function initializeCharts() {
    if (memoryUsageChart) {
      memoryUsageChart.destroy();
    }
    if (responseTimeChart) {
      responseTimeChart.destroy();
    }
    if (nonHeapChart) {
      nonHeapChart.destroy();
    }
    if (threadChart) {
      threadChart.destroy();
    }

    const memoryCtx = document.getElementById('memoryChart').getContext('2d');
    const responseCtx = document.getElementById('responseTimeChart').getContext('2d');
    const nonHeapCtx = document.getElementById('nonHeapChart').getContext('2d');
    const threadCtx = document.getElementById('threadChart').getContext('2d');

    // Memory Chart
    memoryUsageChart = new Chart(memoryCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Heap Usage',
            borderColor: 'rgb(54, 162, 235)',
            data: []
          },
          {
            label: 'Young Gen',
            borderColor: 'rgb(255, 99, 132)',
            data: []
          },
          {
            label: 'Old Gen',
            borderColor: 'rgb(75, 192, 192)',
            data: []
          }
        ]
      },
      options: createChartOptions('Memory Usage (MB)')
    });

    // Non-Heap Memory Chart
    nonHeapChart = new Chart(nonHeapCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Non-Heap Used',
            borderColor: 'rgb(153, 102, 255)',
            data: []
          },
          {
            label: 'Metaspace Used',
            borderColor: 'rgb(255, 159, 64)',
            data: []
          }
        ]
      },
      options: createChartOptions('Non-Heap Memory (MB)')
    });

    // Thread Chart
    threadChart = new Chart(threadCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Active Threads',
            borderColor: 'rgb(75, 192, 192)',
            data: []
          },
          {
            label: 'Queue Size',
            borderColor: 'rgb(255, 205, 86)',
            data: []
          }
        ]
      },
      options: createChartOptions('Thread Pool Status')
    });

    // Response Time Chart
    responseTimeChart = new Chart(responseCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Response Time (ms)',
          borderColor: 'rgb(75, 192, 192)',
          data: []
        }]
      },
      options: createChartOptions('Response Time (ms)')
    });
  }

  function createChartOptions(yAxisLabel) {
    return {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: yAxisLabel
          }
        }
      },
      animation: {
        duration: 0
      }
    };
  }

  // 차트 실시간 업데이트
  function updateChartsWithNewData(metrics, testStatus) {
    if (!metrics || !testStatus) {
      return;
    }

    if (testStatus.completed) {
      return;
    }

    // 힙 메모리 차트
    updateHeapMemoryChart(metrics);

    // 논힙 메모리 차트
    updateNonHeapMemoryChart(metrics);

    // 스레드 풀 차트
    updateThreadPoolChart(metrics);

    // 응답시간 차트
    updateResponseTimeChart(testStatus);
  }

  function updateHeapMemoryChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);

    if (memoryUsageChart.data.labels.length > 50) {
      memoryUsageChart.data.labels.shift();
      memoryUsageChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    memoryUsageChart.data.labels.push(timestamp);
    memoryUsageChart.data.datasets[0].data.push(metrics.heapUsed / (1024 * 1024));
    memoryUsageChart.data.datasets[1].data.push(metrics.youngGenUsed / (1024 * 1024));
    memoryUsageChart.data.datasets[2].data.push(metrics.oldGenUsed / (1024 * 1024));

    memoryUsageChart.update();
  }

  function updateNonHeapMemoryChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);

    if (nonHeapChart.data.labels.length > 50) {
      nonHeapChart.data.labels.shift();
      nonHeapChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    nonHeapChart.data.labels.push(timestamp);
    nonHeapChart.data.datasets[0].data.push(metrics.nonHeapUsed / (1024 * 1024));
    nonHeapChart.data.datasets[1].data.push(metrics.metaspaceUsed / (1024 * 1024));

    nonHeapChart.update();
  }

  function updateThreadPoolChart(metrics) {
    const timestamp = formatTime(metrics.timestamp);
    const pool = metrics.performanceThreadPool;

    if (!pool) {
      return;
    }

    if (threadChart.data.labels.length > 50) {
      threadChart.data.labels.shift();
      threadChart.data.datasets.forEach(dataset => dataset.data.shift());
    }

    threadChart.data.labels.push(timestamp);
    threadChart.data.datasets[0].data.push(pool.activeThreads);
    threadChart.data.datasets[1].data.push(pool.queueSize);

    // 새로운 데이터셋 추가
    if (threadChart.data.datasets.length === 2) {
      threadChart.data.datasets.push({
        label: 'Pool Size',
        borderColor: 'rgb(153, 102, 255)',
        data: [pool.poolSize]
      });
    } else {
      threadChart.data.datasets[2].data.push(pool.poolSize);
    }

    threadChart.update();
  }

  function updateResponseTimeChart(testStatus) {
    responseTimeChart.data = {
      labels: testStatus.responseTimes.map((_, i) => i + 1),
      datasets: [{
        label: 'Response Time (ms)',
        data: testStatus.responseTimes,
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }]
    };

    responseTimeChart.update();
  }

  // 메서드별 스레드 메트릭 업데이트
  function updateMethodThreadMetrics(threadMetrics) {
    if (!threadMetrics) {
      clearMethodThreadMetrics();
      return;
    }

    // DOM 업데이트 전에 값 체크 및 포맷팅
    const threadName = threadMetrics.threadName || '-';
    const threadId = threadMetrics.threadId || '-';
    const cpuTime = threadMetrics.threadCpuTime ? formatDuration(threadMetrics.threadCpuTime) : '-';
    const userTime = threadMetrics.threadUserTime ? formatDuration(threadMetrics.threadUserTime)
        : '-';
    const threadState = threadMetrics.threadState || '-';
    const priority = threadMetrics.priority || '-';
    const isDaemon = threadMetrics.isDaemon != null ? (threadMetrics.isDaemon ? 'Yes' : 'No') : '-';

    // DOM 업데이트
    document.getElementById('method-thread-name').textContent = threadName;
    document.getElementById('method-thread-id').textContent = threadId;
    document.getElementById('method-cpu-time').textContent = cpuTime;
    document.getElementById('method-user-time').textContent = userTime;
    document.getElementById('method-thread-state').textContent = threadState;
    document.getElementById('method-thread-priority').textContent = priority;
    document.getElementById('method-thread-daemon').textContent = isDaemon;

    // 스택 트레이스 저장
    window.currentStackTrace = threadMetrics.stackTrace || null;
  }

  function clearMethodThreadMetrics() {
    document.getElementById('method-thread-name').textContent = '-';
    document.getElementById('method-thread-id').textContent = '-';
    document.getElementById('method-cpu-time').textContent = '-';
    document.getElementById('method-user-time').textContent = '-';
    document.getElementById('method-thread-state').textContent = '-';
    document.getElementById('method-thread-priority').textContent = '-';
    document.getElementById('method-thread-daemon').textContent = '-';
    window.currentStackTrace = null;
  }

  // 스택 트레이스 표시
  function showStackTrace() {
    const stackTraceContent = document.getElementById('stack-trace-content');
    if (!window.currentStackTrace || !Array.isArray(window.currentStackTrace)) {
      stackTraceContent.textContent = 'No stack trace available';
    } else {
      const formattedTrace = window.currentStackTrace
      .map(
          frame => `    at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})`)
      .join('\n');
      stackTraceContent.textContent = formattedTrace || 'Empty stack trace';
    }

    const modal = new bootstrap.Modal(document.getElementById('stackTraceModal'));
    modal.show();
  }

  // 시간 포맷팅
  function formatDuration(nanos) {
    if (!nanos) {
      return '-';
    }
    const ms = nanos / 1_000_000;
    return `${ms.toFixed(2)} ms`;
  }

  // 모달 내용 업데이트
  function updateModalContent(result) {
    if (!result) {
      console.warn('No result data provided to updateModalContent');
      return;
    }

    // 기본 정보 업데이트
    updateElement('modal-description', result.description);
    updateElement('modal-url', result.url);
    updateElement('modal-method', result.method);
    updateElement('modal-duration', calculateDuration(result.startTime, new Date()));

    // 테스트 결과 업데이트
    updateElement('modal-total-requests', result.totalRequests || 0);
    updateElement('modal-success-rate', `${(100 - (result.errorRate || 0)).toFixed(2)}%`);
    updateElement('modal-avg-response', `${(result.averageResponseTime || 0).toFixed(2)} ms`);
    updateElement('modal-rps', (result.requestsPerSecond || 0).toFixed(2));

    // 메모리 메트릭 업데이트
    updateElement('modal-heap-used', formatBytes(result.metrics?.heapUsed || 0));
    updateElement('modal-heap-max', formatBytes(result.metrics?.heapMax || 0));
    updateElement('modal-young-gen', formatBytes(result.metrics?.youngGenUsed || 0));
    updateElement('modal-old-gen', formatBytes(result.metrics?.oldGenUsed || 0));

    updateElement('modal-nonheap-used', formatBytes(result.metrics?.nonHeapUsed || 0));
    updateElement('modal-nonheap-committed', formatBytes(result.metrics?.nonHeapCommitted || 0));
    updateElement('modal-metaspace-used', formatBytes(result.metrics?.metaspaceUsed || 0));

    updateElement('modal-young-gc-count', result.metrics?.youngGcCount || 0);
    updateElement('modal-old-gc-count', result.metrics?.oldGcCount || 0);
    updateElement('modal-gc-time',
        `${result.metrics?.youngGcTime + result.metrics?.oldGcTime || 0} ms`);

    // 스레드 상태 업데이트
    updateElement('modal-active-threads', result.metrics?.activeThreads || 0);
    updateElement('modal-pool-size', result.metrics?.poolSize || 0);
    updateElement('modal-max-pool-size', result.metrics?.maxPoolSize || 0);
    updateElement('modal-queue-size', result.metrics?.queueSize || 0);

    // 스레드 상태 카운트 업데이트
    updateElement('modal-running-threads', result.metrics?.runningThreads || 0);
    updateElement('modal-waiting-threads', result.metrics?.waitingThreads || 0);
    updateElement('modal-blocked-threads', result.metrics?.blockedThreads || 0);
    updateElement('modal-total-threads', result.metrics?.threadCount || 0);

    // 메서드 스레드 메트릭 업데이트
    if (result.threadMetrics) {
      updateMethodThreadMetrics(result.threadMetrics);
    }
  }

  // 헬퍼 함수들
  function updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) {
      element.textContent = value;
    }
  }

  function formatBytes(bytes) {
    if (!bytes) {
      return '0 MB';
    }
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(2)} MB`;
  }

  function calculateDuration(startTime, endTime) {
    if (!startTime) {
      return '0 seconds';
    }
    const start = new Date(startTime);
    const end = new Date(endTime);
    const diff = (end - start) / 1000;
    return `${diff.toFixed(1)} seconds`;
  }

  function escapeHtml(unsafe) {
    if (unsafe == null) {
      return '';
    }
    return unsafe
    .toString()
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
  }

  function formatNumber(value) {
    if (value == null) {
      return '-';
    }
    return typeof value === 'number' ? value.toFixed(2) : value;
  }

  function getStatusText(status) {
    if (!status) {
      return '-';
    }
    if (status.status === 'ERROR') {
      return 'Error';
    }
    if (status.status === 'TIMEOUT') {
      return 'Timeout';
    }
    if (status.completed) {
      return 'Completed';
    }
    return 'Running';
  }

  function getStatusClass(status) {
    if (!status) {
      return '';
    }
    if (status.status === 'ERROR' || status.status === 'TIMEOUT') {
      return 'table-danger';
    }
    if (status.completed) {
      return status.errorRate > 10 ? 'table-warning' : 'table-success';
    }
    return 'table-info';
  }

  function formatTime(timestamp) {
    // timestamp가 배열인 경우
    if (Array.isArray(timestamp)) {
      const [year, month, day, hour, minute, second, nano] = timestamp;
      return `${hour}:${minute}:${second}`;
    }
    // 문자열인 경우
    const date = new Date(timestamp);
    return date.toLocaleTimeString();
  }

  // 초기 테스트 결과 로딩
  window.addEventListener('load', async () => {
    try {
      const response = await fetch('/performanceMeasure/results');
      if (response.ok) {
        const results = await response.json();
        results.forEach(result => updateResultsTable(result));
      }
    } catch (error) {
      console.error('Failed to load test results:', error);
    }
  });
</script>
</body>
</html>